<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305576 (zh-CN, DDL); Windows/6.1.7600 (Win64);"/>
  <meta name="reminder-order" content="2016/12/2 5:36"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1338"/>

<div>
<span><div><b><span style="font-size: 19px;">构造函数(类)</span></b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">function Person(firstname){</span></div><div><span style="font-size: 16px;">     this.firstname = firstname;</span></div><div><span style="font-size: 16px;">}</span></div></div><div><br/></div><div><span style="font-size: 19px;"><b>使用方式 </b></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">var p = new Person(&quot;隔壁老王&quot;);</span></div><div><span style="font-size: 16px;">console.log(p.firstname);</span></div></div><div><br/></div><div><span style="font-size: 19px;"><b>对象可以更明确的区分类型</b></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">var p1 = new Person(&quot;宋喆&quot;);</span></div><div><span style="font-size: 16px;">var s1 = new Student(&quot;小明&quot;);</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">console.log(p1 instanceof Person);</span></div></div><div><br/></div><div><span style="font-size: 19px;"><b>也可以手动返回一个对象</b></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">function Smartisan(){</span></div><div><span style="font-size: 16px;">     this.color = &quot;black&quot;;</span></div><div><span style="font-size: 16px;">     return {</span></div><div><span style="font-size: 16px;">         //..... </span></div><div><span style="font-size: 16px;">     };</span></div><div><span style="font-size: 16px;">}</span></div></div><div><br/></div><div><span style="font-size: 19px;"><b>为什么函数也有函数？</b></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;"><span style="color: rgb(118, 0, 216);">因为函数是一种特殊的对象</span></span></div><div><span style="font-size: 16px;">var m1 = new Function();</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><span style="color: rgb(255, 0, 0);">Function 是函数的构造函数</span></span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">m1(); //空函数</span></div></div><div><br/></div><div><b><span style="font-size: 19px;">使用Function如何创建函数?</span></b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">var temp = new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a+b&quot;);</span></div><div><span style="font-size: 16px;">temp(5,9); //14</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">执行期间动态创建，创建效率较低</span></div></div><div><br/></div><div><b><span style="font-size: 19px;">继承</span></b></div><div><b><span style="font-size: 19px;"><br/></span></b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><span style="font-size: 16px;">class A <span style="color: rgb(255, 0, 0);">extends</span> B </span></div><div><b><span style="font-size: 19px;"><br/></span></b></div><div><b><span style="font-size: 19px;">继承的方式一</span></b></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">function Father(){</span></div><div><span style="font-size: 16px;">     this.money = 1000000;</span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">function Son(){</span></div><div><span style="font-size: 16px;">     this.p = Father;</span></div><div><span style="font-size: 16px;">     this.p();</span></div><div><span style="font-size: 16px;">     delete this.p;</span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">var s = new Son();</span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><b><span style="font-size: 19px;">call方法是什么？</span></b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 15px;">可以理解为呼叫，或者调用</span></div><div><span style="font-size: 15px;"><br/></span></div><div><span style="font-size: 15px;">函数不可独立存在，总是要依附于某个对象，不管是自定义的，还是全局的，因此函数的执行，总是这样：</span></div><div><span style="font-size: 15px;"><br/></span></div><div><span style="font-size: 15px;"><span style="color: rgb(255, 0, 0);">obj.func();  //表示对象obj调用了func</span></span></div><div><span style="font-size: 15px;"><br/></span></div><div><span style="font-size: 15px;">但我们也可以反过来:</span></div><div><span style="font-size: 15px;"><br/></span></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 15px;">func.call(obj);  //函数func被调用了，通过obj</span></span></div><div><span style="font-size: 15px;"><br/></span></div><div><span style="font-size: 15px;">如果需要传参数：</span></div><div><span style="font-size: 15px;"><br/></span></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 15px;">func.call(obj, param1, param2,....);</span></span></div></div><div><br/></div><div><b><span style="font-size: 19px;">于是我们就有了继承方式二：</span></b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">function Father(){</span></div><div><span style="font-size: 16px;">     this.money = 1000000;     </span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">function Son(){</span></div><div><span style="font-size: 16px;">     Father.call(this);</span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><span style="color: rgb(255, 0, 0);">但有时候参数太多:</span></span></div><div><span style="font-size: 16px;">function Father(p1,p2,p3,p4){</span></div><div><span style="font-size: 16px;">     this.money = 1000000;</span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">function Son(v1,v2,v3,v4){</span></div><div><span style="font-size: 16px;">     Father.call(this, v1, v2, v3, v4);</span></div><div><span style="font-size: 16px;">}</span></div></div><div><br/></div><div><span style="font-size: 19px;">于是我们就有了继承方式三：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">function Father(p1,p2,p3,p4){</span></div><div><span style="font-size: 16px;">     this.money = 1000000;</span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">function Son(v1,v2,v3,v4){</span></div><div><span style="font-size: 16px;">     Father.apply(this, [v1, v2, v3, v4]);</span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;"><span style="color: rgb(255, 0, 0);">可以再改造一下：</span></span></div><div><span style="font-size: 16px;">function Son(){</span></div><div><span style="font-size: 16px;">     Father.apply(this, arguments);</span></div><div><span style="font-size: 16px;">}</span></div></div><div><br/></div><div>prototype是什么？</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><img src="构造函数与继承_files/Image.png" type="image/png" data-filename="Image.png" style="height:auto;" width="637"/></div></div><div><br/></div><div>原型能干什么？</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>扩展函数的能力</div></div><div><br/></div><div>利用prototype，继承方式四：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function Father(){    }</div><div>Father.prototype.talk = function(){   }</div><div>function Son(){    }</div><div>Son.prototype = new Father();</div></div><div><br/></div><div>最常见的混合继承；</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function Father(){</div><div>     </div><div>}</div><div>Father.prototype.liaomei = function(){</div><div><br/></div><div>}</div><div>Son.prototype = new Father();</div><div>function Son(){</div><div>     Father.apply(this,arguments);    </div><div>}</div></div><div><br/></div><div><br/></div><div><b><span style="font-size: 19px;">原型继承中的 原型链</span></b></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><img src="构造函数与继承_files/原型链.png" type="image/png" data-filename="原型链.png"/></div></div><div><b><span style="font-size: 19px;"><br/></span></b></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 